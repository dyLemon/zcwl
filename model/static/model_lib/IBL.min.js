THREE.HDRCubeTextureLoader=function(t){this.manager=void 0!==t?t:THREE.DefaultLoadingManager,this.hdrLoader=new THREE.RGBELoader},THREE.HDRCubeTextureLoader.prototype.load=function(c,a,t,e,n){var l=function(t,e,n,a){var r=t[e+3],i=Math.pow(2,r-128)/255;n[a+0]=t[e+0]*i,n[a+1]=t[e+1]*i,n[a+2]=t[e+2]*i},p=function(){var i=new Float32Array(1),o=new Int32Array(i.buffer);function s(t){i[0]=t;var e=o[0],n=e>>16&32768,a=e>>12&2047,r=e>>23&255;return r<103?n:142<r?(n|=31744,n|=(255==r?0:1)&&8388607&e):r<113?n|=((a|=2048)>>114-r)+(a>>113-r&1):(n|=r-112<<10|a>>1,n+=1&a)}return function(t,e,n,a){var r=t[e+3],i=Math.pow(2,r-128)/255;n[a+0]=s(t[e+0]*i),n[a+1]=s(t[e+1]*i),n[a+2]=s(t[e+2]*i)}}(),v=new THREE.CubeTexture;v.type=c,v.encoding=c===THREE.UnsignedByteType?THREE.RGBEEncoding:THREE.LinearEncoding,v.format=c===THREE.UnsignedByteType?THREE.RGBAFormat:THREE.RGBFormat,v.minFilter=v.encoding===THREE.RGBEEncoding?THREE.NearestFilter:THREE.LinearFilter,v.magFilter=v.encoding===THREE.RGBEEncoding?THREE.NearestFilter:THREE.LinearFilter,v.generateMipmaps=v.encoding!==THREE.RGBEEncoding,v.anisotropy=0;var m=this.hdrLoader,d=0;function r(s,u,t,e){var n=new THREE.FileLoader(m.manager);n.setResponseType("arraybuffer"),n.load(a[s],function(t){d++;var e=m._parser(t);if(e){if(c===THREE.FloatType){for(var n=e.data.length/4*3,a=new Float32Array(n),r=0;r<n;r++)l(e.data,4*r,a,3*r);e.data=a}else if(c===THREE.HalfFloatType){n=e.data.length/4*3;var i=new Uint16Array(n);for(r=0;r<n;r++)p(e.data,4*r,i,3*r);e.data=i}if(void 0!==e.image)v[s].images=e.image;else if(void 0!==e.data){var o=new THREE.DataTexture(e.data,e.width,e.height);o.format=v.format,o.type=v.type,o.encoding=v.encoding,o.minFilter=v.minFilter,o.magFilter=v.magFilter,o.generateMipmaps=v.generateMipmaps,v.images[s]=o}6===d&&(v.needsUpdate=!0,u&&u(v))}},t,e)}for(var i=0;i<a.length;i++)r(i,t,e,n);return v},THREE.PMREMCubeUVPacker=function(t){var e=4*(this.cubeLods=t)[0].width,n=t[0].texture,a={format:n.format,magFilter:n.magFilter,minFilter:n.minFilter,type:n.type,generateMipmaps:n.generateMipmaps,anisotropy:n.anisotropy,encoding:n.encoding===THREE.RGBEEncoding?THREE.RGBM16Encoding:n.encoding};a.encoding===THREE.RGBM16Encoding&&(a.magFilter=THREE.LinearFilter,a.minFilter=THREE.LinearFilter),this.CubeUVRenderTarget=new THREE.WebGLRenderTarget(e,e,a),this.CubeUVRenderTarget.texture.name="PMREMCubeUVPacker.cubeUv",this.CubeUVRenderTarget.texture.mapping=THREE.CubeUVReflectionMapping,this.camera=new THREE.OrthographicCamera(.5*-e,.5*e,.5*-e,.5*e,0,1),this.scene=new THREE.Scene,this.objects=[];var r=new THREE.PlaneBufferGeometry(1,1),i=[];i.push(new THREE.Vector2(0,0)),i.push(new THREE.Vector2(1,0)),i.push(new THREE.Vector2(2,0)),i.push(new THREE.Vector2(0,1)),i.push(new THREE.Vector2(1,1)),i.push(new THREE.Vector2(2,1));var o=e;e=t[0].width;var s=0,u=4;this.numLods=Math.log(t[0].width)/Math.log(2)-2;for(var c=0;c<this.numLods;c++){var l=.5*(o-o/u);16<e&&(u*=2);for(var p=16<e?6:1,v=0,m=0,d=e,E=0;E<p;E++){for(var h=0;h<6;h++){var f=this.getShader();f.uniforms.envMap.value=this.cubeLods[c].texture,f.envMap=this.cubeLods[c].texture,f.uniforms.faceIndex.value=h,f.uniforms.mapSize.value=d;var g=new THREE.Mesh(r,f);g.position.x=i[h].x*d-l+v,g.position.y=i[h].y*d-l+s+m,g.material.side=THREE.BackSide,g.scale.setScalar(d),this.scene.add(g),this.objects.push(g)}m+=1.75*d,v+=1.25*d,d/=2}s+=2*e,16<e&&(e/=2)}},THREE.PMREMCubeUVPacker.prototype={constructor:THREE.PMREMCubeUVPacker,update:function(t){var e=t.gammaInput,n=t.gammaOutput,a=t.toneMapping,r=t.toneMappingExposure,i=t.getRenderTarget();t.gammaInput=!1,t.gammaOutput=!1,t.toneMapping=THREE.LinearToneMapping,t.toneMappingExposure=1,t.render(this.scene,this.camera,this.CubeUVRenderTarget,!1),t.setRenderTarget(i),t.toneMapping=a,t.toneMappingExposure=r,t.gammaInput=e,t.gammaOutput=n},getShader:function(){var t=new THREE.ShaderMaterial({uniforms:{faceIndex:{value:0},mapSize:{value:0},envMap:{value:null},testColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"precision highp float;\t\t\t\tvarying vec2 vUv;\t\t\t\tvoid main() {\t\t\t\t\tvUv = uv;\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\t\t\t\t}",fragmentShader:"precision highp float;\t\t\t\tvarying vec2 vUv;\t\t\t\tuniform samplerCube envMap;\t\t\t\tuniform float mapSize;\t\t\t\tuniform vec3 testColor;\t\t\t\tuniform int faceIndex;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tvec3 sampleDirection;\t\t\t\t\tvec2 uv = vUv;\t\t\t\t\tuv = uv * 2.0 - 1.0;\t\t\t\t\tuv.y *= -1.0;\t\t\t\t\tif(faceIndex == 0) {\t\t\t\t\t\tsampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\t\t\t\t\t} else if(faceIndex == 1) {\t\t\t\t\t\tsampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\t\t\t\t\t} else if(faceIndex == 2) {\t\t\t\t\t\tsampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\t\t\t\t\t} else if(faceIndex == 3) {\t\t\t\t\t\tsampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\t\t\t\t\t} else if(faceIndex == 4) {\t\t\t\t\t\tsampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\t\t\t\t\t} else {\t\t\t\t\t\tsampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\t\t\t\t\t}\t\t\t\t\tvec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\t\t\t\t\tgl_FragColor = linearToOutputTexel( color );\t\t\t\t}",blending:THREE.NoBlending});return t.type="PMREMCubeUVPacker",t},dispose:function(){for(var t=0,e=this.objects.length;t<e;t++)this.objects[t].material.dispose();this.objects[0].geometry.dispose()}},THREE.PMREMGenerator=function(t,e,n){this.sourceTexture=t,this.resolution=void 0!==n?n:256,this.samplesPerLevel=void 0!==e?e:16;var a=t.encoding===THREE.LinearEncoding||t.encoding===THREE.GammaEncoding||t.encoding===THREE.sRGBEncoding;this.sourceTexture.minFilter=a?THREE.LinearFilter:THREE.NearestFilter,this.sourceTexture.magFilter=a?THREE.LinearFilter:THREE.NearestFilter,this.sourceTexture.generateMipmaps=this.sourceTexture.generateMipmaps&&a,this.cubeLods=[];var r=this.resolution,i={format:this.sourceTexture.format,magFilter:this.sourceTexture.magFilter,minFilter:this.sourceTexture.minFilter,type:this.sourceTexture.type,generateMipmaps:this.sourceTexture.generateMipmaps,anisotropy:this.sourceTexture.anisotropy,encoding:this.sourceTexture.encoding};this.numLods=Math.log(r)/Math.log(2)-2;for(var o=0;o<this.numLods;o++){var s=new THREE.WebGLRenderTargetCube(r,r,i);s.texture.name="PMREMGenerator.cube"+o,this.cubeLods.push(s),r=Math.max(16,r/2)}this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1e3),this.shader=this.getShader(),this.shader.defines.SAMPLES_PER_LEVEL=this.samplesPerLevel,this.planeMesh=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2,0),this.shader),this.planeMesh.material.side=THREE.DoubleSide,this.scene=new THREE.Scene,this.scene.add(this.planeMesh),this.scene.add(this.camera),this.shader.uniforms.envMap.value=this.sourceTexture,this.shader.envMap=this.sourceTexture},THREE.PMREMGenerator.prototype={constructor:THREE.PMREMGenerator,update:function(t){this.shader.uniforms.envMap.value=this.sourceTexture,this.shader.envMap=this.sourceTexture;var e=t.gammaInput,n=t.gammaOutput,a=t.toneMapping,r=t.toneMappingExposure,i=t.getRenderTarget();t.toneMapping=THREE.LinearToneMapping,t.toneMappingExposure=1,t.gammaInput=!1,t.gammaOutput=!1;for(var o=0;o<this.numLods;o++){var s=o/(this.numLods-1);this.shader.uniforms.roughness.value=.9*s,this.shader.uniforms.queryScale.value.x=0==o?-1:1;var u=this.cubeLods[o].width;this.shader.uniforms.mapSize.value=u,this.renderToCubeMapTarget(t,this.cubeLods[o]),o<5&&(this.shader.uniforms.envMap.value=this.cubeLods[o].texture)}t.setRenderTarget(i),t.toneMapping=a,t.toneMappingExposure=r,t.gammaInput=e,t.gammaOutput=n},renderToCubeMapTarget:function(t,e){for(var n=0;n<6;n++)this.renderToCubeMapTargetFace(t,e,n)},renderToCubeMapTargetFace:function(t,e,n){e.activeCubeFace=n,this.shader.uniforms.faceIndex.value=n,t.render(this.scene,this.camera,e,!0)},getShader:function(){var t=new THREE.ShaderMaterial({defines:{SAMPLES_PER_LEVEL:20},uniforms:{faceIndex:{value:0},roughness:{value:.5},mapSize:{value:.5},envMap:{value:null},queryScale:{value:new THREE.Vector3(1,1,1)},testColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform int faceIndex;\n\t\t\t\tuniform float roughness;\n\t\t\t\tuniform samplerCube envMap;\n\t\t\t\tuniform float mapSize;\n\t\t\t\tuniform vec3 testColor;\n\t\t\t\tuniform vec3 queryScale;\n\t\t\t\t\n\t\t\t\tfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\t\t\t\t\tfloat a = ggxRoughness + 0.0001;\n\t\t\t\t\ta *= a;\n\t\t\t\t\treturn ( 2.0 / a - 2.0 );\n\t\t\t\t}\n\t\t\t\tvec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\n\t\t\t\t\tfloat phi = uv.y * 2.0 * PI;\n\t\t\t\t\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\n\t\t\t\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\t\t\t\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\t\t\t\t\treturn vecSpace * sampleDir;\n\t\t\t\t}\n\t\t\t\tvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\n\t\t\t\t{\n\t\t\t\t\tfloat a = Roughness * Roughness;\n\t\t\t\t\tfloat Phi = 2.0 * PI * uv.x;\n\t\t\t\t\tfloat CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\n\t\t\t\t\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\t\t\t\t\treturn vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\n\t\t\t\t}\n\t\t\t\tmat3 matrixFromVector(vec3 n) {\n\t\t\t\t\tfloat a = 1.0 / (1.0 + n.z);\n\t\t\t\t\tfloat b = -n.x * n.y * a;\n\t\t\t\t\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\t\t\t\t\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\t\t\t\t\treturn mat3(b1, b2, n);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec4 testColorMap(float Roughness) {\n\t\t\t\t\tvec4 color;\n\t\t\t\t\tif(faceIndex == 0)\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,0.0,1.0);\n\t\t\t\t\telse if(faceIndex == 1)\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,0.0,1.0);\n\t\t\t\t\telse if(faceIndex == 2)\n\t\t\t\t\t\tcolor = vec4(0.0,0.0,1.0,1.0);\n\t\t\t\t\telse if(faceIndex == 3)\n\t\t\t\t\t\tcolor = vec4(1.0,1.0,0.0,1.0);\n\t\t\t\t\telse if(faceIndex == 4)\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,1.0,1.0);\n\t\t\t\t\telse\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,1.0,1.0);\n\t\t\t\t\tcolor *= ( 1.0 - Roughness );\n\t\t\t\t\treturn color;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec3 sampleDirection;\n\t\t\t\t\tvec2 uv = vUv*2.0 - 1.0;\n\t\t\t\t\tfloat offset = -1.0/mapSize;\n\t\t\t\t\tconst float a = -1.0;\n\t\t\t\t\tconst float b = 1.0;\n\t\t\t\t\tfloat c = -1.0 + offset;\n\t\t\t\t\tfloat d = 1.0 - offset;\n\t\t\t\t\tfloat bminusa = b - a;\n\t\t\t\t\tuv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\n\t\t\t\t\tuv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\n\t\t\t\t\tif (faceIndex==0) {\n\t\t\t\t\t\tsampleDirection = vec3(1.0, -uv.y, -uv.x);\n\t\t\t\t\t} else if (faceIndex==1) {\n\t\t\t\t\t\tsampleDirection = vec3(-1.0, -uv.y, uv.x);\n\t\t\t\t\t} else if (faceIndex==2) {\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, 1.0, uv.y);\n\t\t\t\t\t} else if (faceIndex==3) {\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -1.0, -uv.y);\n\t\t\t\t\t} else if (faceIndex==4) {\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -uv.y, 1.0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsampleDirection = vec3(-uv.x, -uv.y, -1.0);\n\t\t\t\t\t}\n\t\t\t\t\tmat3 vecSpace = matrixFromVector(normalize(sampleDirection * queryScale));\n\t\t\t\t\tvec3 rgbColor = vec3(0.0);\n\t\t\t\t\tconst int NumSamples = SAMPLES_PER_LEVEL;\n\t\t\t\t\tvec3 vect;\n\t\t\t\t\tfloat weight = 0.0;\n\t\t\t\t\tfor( int i = 0; i < NumSamples; i ++ ) {\n\t\t\t\t\t\tfloat sini = sin(float(i));\n\t\t\t\t\t\tfloat cosi = cos(float(i));\n\t\t\t\t\t\tfloat r = rand(vec2(sini, cosi));\n\t\t\t\t\t\tvect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\n\t\t\t\t\t\tfloat dotProd = dot(vect, normalize(sampleDirection));\n\t\t\t\t\t\tweight += dotProd;\n\t\t\t\t\t\tvec3 color = envMapTexelToLinear(textureCube(envMap,vect)).rgb;\n\t\t\t\t\t\trgbColor.rgb += color;\n\t\t\t\t\t}\n\t\t\t\t\trgbColor /= float(NumSamples);\n\t\t\t\t\t//rgbColor = testColorMap( roughness ).rgb;\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\n\t\t\t\t}",blending:THREE.NoBlending});return t.type="PMREMGenerator",t},dispose:function(){for(var t=0,e=this.cubeLods.length;t<e;t++)this.cubeLods[t].dispose();this.planeMesh.geometry.dispose(),this.planeMesh.material.dispose()}},THREE.HDRLoader=THREE.RGBELoader=function(t){this.manager=void 0!==t?t:THREE.DefaultLoadingManager},THREE.RGBELoader.prototype=Object.create(THREE.DataTextureLoader.prototype),THREE.RGBELoader.prototype._parser=function(t){var g=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},u=function(t,e,n){e=e||1024;for(var a=t.pos,r=-1,i=0,o="",s=String.fromCharCode.apply(null,new Uint16Array(t.subarray(a,a+128)));(r=s.indexOf("\n"))<0&&i<e&&a<t.byteLength;)o+=s,i+=s.length,a+=128,s+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(a,a+128)));return-1<r&&(!1!==n&&(t.pos+=i+r+1),o+s.slice(0,r))},e=new Uint8Array(t);e.byteLength;e.pos=0;var n=function(t){var e,n,a=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};if(t.pos>=t.byteLength||!(e=u(t)))return g(1,"no header found");if(!(n=e.match(/^#\?(\S+)$/)))return g(3,"bad initial token");for(s.valid|=1,s.programtype=n[1],s.string+=e+"\n";!1!==(e=u(t));)if(s.string+=e+"\n","#"!==e.charAt(0)){if((n=e.match(a))&&(s.gamma=parseFloat(n[1],10)),(n=e.match(r))&&(s.exposure=parseFloat(n[1],10)),(n=e.match(i))&&(s.valid|=2,s.format=n[1]),(n=e.match(o))&&(s.valid|=4,s.height=parseInt(n[1],10),s.width=parseInt(n[2],10)),2&s.valid&&4&s.valid)break}else s.comments+=e+"\n";return 2&s.valid?4&s.valid?s:g(3,"missing image size specifier"):g(3,"missing format specifier")}(e);if(-1!==n){var a=n.width,r=n.height,i=function(t,e,n){var a,r,i,o,s,u,c,l,p,v,m,d,E,h=e,f=n;if(h<8||32767<h||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(h!==(t[2]<<8|t[3]))return g(3,"wrong scanline width");if(!(a=new Uint8Array(4*e*n))||!a.length)return g(4,"unable to allocate buffer space");for(i=r=0,l=4*h,E=new Uint8Array(4),u=new Uint8Array(l);0<f&&i<t.byteLength;){if(i+4>t.byteLength)return g(1);if(E[0]=t[i++],E[1]=t[i++],E[2]=t[i++],E[3]=t[i++],2!=E[0]||2!=E[1]||(E[2]<<8|E[3])!=h)return g(3,"bad rgbe scanline format");for(c=0;c<l&&i<t.byteLength;){if((d=128<(o=t[i++]))&&(o-=128),0===o||l<c+o)return g(3,"bad scanline data");if(d)for(s=t[i++],p=0;p<o;p++)u[c++]=s;else u.set(t.subarray(i,i+o),c),c+=o,i+=o}for(v=h,p=0;p<v;p++)m=0,a[r]=u[p+m],m+=h,a[r+1]=u[p+m],m+=h,a[r+2]=u[p+m],m+=h,a[r+3]=u[p+m],r+=4;f--}return a}(e.subarray(e.pos),a,r);if(-1!==i)return{width:a,height:r,data:i,header:n.string,gamma:n.gamma,exposure:n.exposure,format:THREE.RGBEFormat,type:THREE.UnsignedByteType}}return null};